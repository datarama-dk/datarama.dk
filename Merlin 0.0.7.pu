%title Merlin 0.0.7
%date 2015-07-31
%subtitle List Processing

Weirdly enough, I've managed to get this far in an implementation of
Lisp without actually having support for, well, **Lis**t
**p**rocessing. At any rate, this revision adds support for the three
traditional Lisp list processing primitives, `cons`, `car` and `cdr`,
along with a type predicate `cons?`. Like in most Lisps (with the 
notable exception of the [Clojure](http://www.clojure.org/) family),
Merlin's `cons` supports arbitrary types on its arguments, and simply
constructs a pair. The first element in such a pair is called the
`car` (or *head*), the second is called the `cdr` (or *tail*). 

This revision introduces two elements into the language that I'm not
uncritically fond of: *Improper lists*, and the often rather clunky
Lisp *list extractors* (`cdadr`, `caaadr`, `cddadr`, etc.). I have a 
plan to deal with the list extractor syntax: A later revision will 
add *pattern matching* and *automatic destructuring of lists*, which 
means that list extraction can be written much more directly.  

I'm still not sure about improper lists. They're an ugly feature, 
they create inconsistencies everywhere, they force a specific
implementation-level structure on lists, and [John McCarthy himself
tried to get rid of them](http://arxiv.org/abs/1505.07375), back in
the 1950s. 

A *proper* list in Lisp is one that is terminated by the empty list,
eg. `(cons 1 ())`, `(cons 2 (cons 1 ()))`, and so forth. In contrast,
an *improper* list is any list that isn't nil-terminated --- 
typically, either circular lists (where the `cdr` of the final
elementpoints to the first element) or dotted lists, where the `cdr`
is just some non-nil atomic data value. All the usual list-processing
library functions that make Lisp such a joy to work with (`map`,
`filter`, `fold`, `reduce` and friends) don't work with improper
lists, and improper lists also usually introduce some weird inconsistencies in the syntax (the infix `.` and special cases for circular
lists). Getting rid of them is easy enough: Removing the infix `.` 
means they can't be constructed syntactically, and constraining `cons`
to require its second argument to be either `nil` or a list means
they can't be constructed programmatically either.

One might reason that adding such a constraint would be an example of
an arbitrary restriction, but it'd be no different from having type
restrictions on other type-sensitive operators, *and* it'd get rid
of the root cause of pervasive restrictions in all the list
processing functions, *and* it'd remove an annoying special case from
the syntax.

The reason I haven't removed improper lists is that there are two
use cases for dotted lists that I use a lot, where I can't currently
think of any good alternative that isn't hideously ugly: Parameter
lists for variadic functions, and pattern matching over lists.
Variadic functions in Scheme look like this: 

    (define (fun arg . more-args)
       ...)

This defines a function `fun` with 1 or more arguments: The first 
gets bound to `arg`, all the others are bound as a list to
`more-args`. The fact that dotted lists *always* have precisely one
element after the dot neatly and syntactically handles the fact
that variadic arguments should be bound into just one identifier. A
way to get variadic functions (which are pervasive in Lisp; all the
built-in operators are variadic, and they're uniquely easy to make
for users too, owing to both the fully parenthesized prefix notation
and the `apply` primitive).

There's a similar benefit to dotted lists in pattern matching over
lists. For example, in a hypothetical pattern-matching Scheme: 

    (define (fun ()) ...)
    (define (fun (x . xs)) ...)

This is a common pattern when iterating over a list in functional
languages, and the dotted list neatly handles the structure of the
list on a syntactic level.

I can think of a variety of possible fixes for both, but I'm not 
entirely happy with any of them. For variadic functions:
 
 * A magic separator symbol
 * A magic "rest of parameters" symbol
 * Symbol annotation
 * Special variadic `λ` variants

Clojure uses a magic separator symbol: The symbol `&` as the second
last parameter in a parameter list means that the next parameter
collects variadic arguments. Unfortunately, this creates confusion
about why `&` doesn't have a similar role in *other* contexts. It 
would also be possible to have the magic symbol *itself* collect 
variadic arguments, for instnce letting the symbol `...` take them
when it's the last symbol in a parameter list.  Another option in the
same spirit would be to allow *annotation* of the final symbol in a
parameter list, for example by letting symbols prefixed with `&`
collect variadic arguments (eg. `&rest` or `&xs`). Finally (and this
is the option that appeals to me most), there could be a `λ&` 
function constructor that always collects variadic arguments in its
last parameter, no matter what it is named. Unfortunately, this
creates an artificial boundary between variadic and "normal"
functions, and demotes variadic funs to a kind of second-class
status, which seems to me to conflict with the spirit of Lisp.

Either of the above options could be adapted to work in pattern
matching too, but there's also another useful option for that
context: Simply use `(cons x xs)` instead of `(x . xs)`, using `cons`
to *construct* pairs in a normal context, and to *destruct* them in
a pattern-matching (this [isn't a new
idea](http://web.mit.edu/amdragon/www/pubs/plaid-6.891.pdf)) context.

A later version might get rid of improper lists, if I can find a good
way to do so.

Download
========
tar.gz: [merlin-0.0.7.tar.gz](files/merlin-0.0.7.tar.gz)  
MD5: `8684686e351b7ea3fc97ee65649c5256`  
SHA256: `410783f9194c520ac0e4f0ba1cbc6a7e45caf0efb08707bf8c1ede5ce58cede8`
